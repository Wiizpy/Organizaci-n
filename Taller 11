//programa en ensamblador para poder manejar la división entre 0 utilizando solamente saltos condicionales.

section .data
msg db "Resultado: ", 0
len equ $ - msg

newline db 10, 0
lenNL equ $ - newline

msgErr db "ERROR: Division entre 0", 0

lenErr equ $ - msgErr

section .bss
resultado resb 1

section .text
global _start

_start:

; ===========================
; Numeros hardcodeados
; ===========================
mov al, '8' ; primer numero (ASCII)
sub al, '0' ; -> 8

mov bl, '2' ; segundo numero (ASCII)
; mov bl, '0' ; <- activar para probar error
sub bl, '0' ; -> entero

; ===========================
; Verificar división entre 0
; ===========================
cmp bl, 0
je division_cero

; ===========================
; División AL / BL

; ===========================
xor ah, ah
div bl ; resultado en AL

; ===========================
; Convertir resultado a ASCII
; ===========================
add al, '0'
mov [resultado], al

; ===========================
; Imprimir "Resultado: "
; ===========================
mov eax, 4
mov ebx, 1
mov ecx, msg
mov edx, len
int 0x80

; ===========================
; Imprimir resultado
; ===========================
mov eax, 4
mov ebx, 1
mov ecx, resultado
mov edx, 1
int 0x80

jmp salto_linea

; ===========================
; Simulación interrupción:
; División entre 0
; ===========================
division_cero:
mov eax, 4
mov ebx, 1
mov ecx, msgErr
mov edx, lenErr
int 0x80
jmp salto_linea

; ===========================
; Salto de línea
; ===========================
salto_linea:
mov eax, 4
mov ebx, 1
mov ecx, newline
mov edx, lenNL
int 0x80

; ===========================
; Salir
; ===========================
mov eax, 1

xor ebx, ebx
int 0x80
